{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Trapdoor Commitment Schemes\n",
    "================================"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## I Introduction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Trapdoors in commitment protocols have already been considered and constructed in the past; they are also called **equivocable commitment schemes** or **chameleon blobs** in the literature. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Commitment\n",
    "\n",
    "Instructively, one can describe a commitment scheme with a lockable steely box. In the so-called commitment phase, one party, the sender, puts a message into a box, locks the box and gives it to the other party, the receiver. On one hand, the receiver cannot open the box to learn the message, and on the other side, the sender cannot change the message anymore."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### non-malleable commitments"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "a commitment scheme is non-malleable if giving the adversary the original commitment of the honest party does not signiﬁcantly increase his success probability of ﬁnding a commitment of a related message (e.g., a higher bid), compared to the case that the adversary does not have access to the honest party’s commitment at all."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### trapdoors commitment"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "These are commitment schemes for which knowledge of a special information, the trapdoor, allows to overcome the binding property and to open a commitment ambiguously.\n",
    "\n",
    "Ambiguous decommitments are only possible given this special information; without, a commitment is still solidly binding."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**E.g.**\n",
    "\n",
    "On the bid auction case:\n",
    "\n",
    "the adversary ﬁrst sees the commitment of the other sender and is supposed to output his commitment to a higher bid afterwards.\n",
    "\n",
    "Assume that the honest sender’s commitment contains a trapdoor but the adversary’s commitment does not. Then, on one hand, the honest party’s bid can still be altered by the trapdoor property in principle, even after the adversary has submitted his value. On the other hand, the adversary’s commitment does not have a trapdoor and his value thenceforth is pinned down due to the binding property."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## II Notation\n",
    "\n",
    "### Turing Machine"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let A be a probabilistic algorithm, or more formally, a Turing machine with a random tape. We say that A is polynomial-time if there exists a polynomial $p(n)$ such that A takes at most $p(n)$ steps on inputs of length $n$.\n",
    "\n",
    "Algorithm A runs in expected polynomial-time if A is polynomial-time on the average, the expectation taken over the internal random coins."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "For a **deterministic algorithm** $A$ let **a = A(x)** be the output a of A on input x.\n",
    "\n",
    "If A is a **probabilistic algorithm** then we denote by **A(x)** the random variable that describes the output of A on input x.\n",
    "\n",
    "The probability space is deﬁned by the internal coin tosses of A.  In this case, we write $[A(x)]$ for the support of A on input x.\n",
    "\n",
    "By $a\\leftarrow A(x)$ we denote the process of sampling an output a of A on input x.\n",
    "\n",
    "$A(x, r)$ is the output of algorithm $A$ on input $x$ with random bits $r$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### circuit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A polynomial-size circuit family is a sequence $C=(C_n)_{n\\in \\mathbb{N}}$ of circuits $C_n$ with the property that the total number of gates of $C_n$, including the input gates, is polynomially bounded in $n$. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## III Trapdoor Commitment Schemes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The discrete-logarithm scheme includes a trapdoor.\n",
    "\n",
    "Let the simulator pick $p, q$ and $g$ as the trusted party, and let it generate $h = g^x \\mod p$ for random $x \\in Z_q$ . The simulator publishes these values.\n",
    "\n",
    "Basically, the value x, or more q precisely, the inverse $x^{-1}$ in, is the trapdoor. because if the simulator commits $q$ on behalf of the sender to some message $m_0$ by sending $M = g^{m_0}h^{r_0}$ for random $r_0 \\in Z_q$, then the simulator can open this commitment with any message $m \\in Z_q$ by computing $r = r_0 - (m - m_0)x^{−1}$. In this case\n",
    "\n",
    "$$\n",
    "M = g^{m0}h^{r0}=g^{m0}h^{r+(m-m_0)x^{-1}}=g^{m_0}h^rg^{m-m_0}=g^mh^r\n",
    "$$\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.types.algebra.concrete import (\n",
    "    EllipticCurveGroupSecp256k1 as ECG,\n",
    "    EllipticCurveCyclicSubgroupSecp256k1 as CG,\n",
    "    FiniteFieldSecp256k1 as F,\n",
    "    FiniteFieldCyclicSecp256k1 as CF\n",
    ")\n",
    "import random\n",
    "\n",
    "N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n",
    "def random_cf() -> CF: return CF(random.randint(1, N) % F.P)\n",
    "G = CG.G\n",
    "x = random_cf()\n",
    "H = G^x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "m0 , r0 = random_cf(), random_cf()\n",
    "M = G**m0 * H**r0 \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "m = random_cf()\n",
    "r = r0 - (m - m0) * ~x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "M == G**m0 * H**r0 == G**m0 * H**(r+((m-m0)*~x)) == G**m * H**r"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Formally, we deﬁne all values necessary to adapt the decommitment as the trap- door, i.e., here $(x, m_0 , r_0)$ form the trapdoor."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A trapdoor function is a function that is easy to compute in one direction, yet difficult to compute in the opposite direction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Ref\n",
    "\n",
    "* Trapdoor function https://en.wikipedia.org/wiki/Trapdoor_function\n",
    "\n",
    "* Fischlin, Marc. (2001). Trapdoor Commitment Schemes and Their Applications. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
