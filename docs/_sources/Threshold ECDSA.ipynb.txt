{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold ECDSA\n",
    "====================="
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold signature schemes enable sharing signing power amongst n parties such that any subset of t + 1 can jointly sign, but any smaller subset cannot.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " ## I Model, Definitions and Tools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.1 Model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### **Communication Model**\n",
    "\n",
    "We assume that our computation model is composed of a set of $n$ players $P_1,\\cdots, P_n$ connected by a complete network of point-to-point channels and a broadcast channel.\n",
    "\n",
    "### **The Adversary**\n",
    "\n",
    "We assume that an adversary, $A$, can corrupt up to $t$ of the $n$ players in the network. $A$ learns all the information stored at the corrupted nodes, and hears all the broadcasted messages. We consider two type of adver saries:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.2 Deﬁnitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### **Signature Scheme**\n",
    "\n",
    "A signature scheme $S$ is a triple of eﬃcient randomized algorithms $(Key-Gen, Sig, Ver)$.\n",
    "\n",
    "* **Key-Gen** is the key generator algorithm.\n",
    "\n",
    "    on input the security parameter $1^\\lambda$ , it outputs a pair $(y, x)$, such that $y$ is the public key and $x$ is the secret key of the signature scheme.\n",
    "\n",
    "* **Sig** is the signing algorithm: \n",
    "\n",
    "    on input a message m and the secret key $x$, it outputs $sig$, a signature of the message $m$. \n",
    "\n",
    "    Since $Sig$ can be a randomized algorithm there might be several valid signatures $sig$ of a message $m$ under the key $x$; with $Sig(m, x)$ we will denote the set of such signatures\n",
    "\n",
    "* **Ver** is the veriﬁcation algorithm.\n",
    "    \n",
    "    On input a message $m$, the public key $y$, and a string $sig$, it checks whether $sig$ is a proper signature of $m$, i.e. if $sig \\in Sig(m, x)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold secret sharing"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given a secret value $x$ we say that the values $(x_1 , \\cdots , x_n)$ constitute a $(t, n)$-threshold secret sharing of $x$ if $t$ (or less) of these values reveal no information about $x$, and if there is an eﬃcient algorithm that outputs $x$ having $t + 1$ of the values $x_i$ as inputs."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold signature schemes."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let $S=(Key-Gen, Sig, Ver)$ be a signature scheme. A $(t, n)$-threshold signature scheme $TS$ for $S$ is a pair of protocols $(Thresh-Key-Gen, Thresh-Sig)$ for the set of players $P_1 , \\cdots, P_n$ ."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* **Thresh-Key-Gen** is a distributed key generation protocol used by the players to jointly generate a pair $(y, x)$ of public/private keys on input a security parameter $1^\\lambda$ .\n",
    "\n",
    "* **Thresh-Sig** is the distributed signature protocol. The private input of $P_i$ is the value $x_i$ . The public inputs consist of a message m and the public key $y$. The output of the protocol is a value $sig \\in Sig(m, x)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1.3 Tools"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Additively Homomorphic Encryption"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We assume the existence of an encryption scheme E which is additively homo- morphic modulo a large integer $N$, One instantiation of a scheme with these properties is **Paillier’s encryption scheme**.\n",
    "\n",
    "ref: [Paillier’s encryption scheme](https://ryankung.github.io/klefki/Paillier's%20encryption%20Scheme.html)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "With $\\oplus_{i=1}^{t+1}$a_i, we denote the summation over the addition operation $+_E$ of the encryption scheme:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "$$\n",
    "\\oplus_{i=1}^{t+1}a_i = a_1 +_E a_2 +_E \\cdots +_E a_{t+1}\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Threshold Cryptosystems"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In a $(t, n)$-threshold cryptosystem, there is a public key $pk$ with a matching secret key $sk$ which is shared among $n$ players with a $(t, n)$-secret sharing.\n",
    "\n",
    "When a message $m$ is encrypted under $pk$, $t+1$ players can decrypt it via a communication protocol that does not expose the secret key."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "More formally, a public key cryptosystem $\\epsilon$ is deﬁned by three eﬃcient algorithms:\n",
    "\n",
    "- key generation **Enc-Key-Gen** that takes as input a security parameter $λ$, and outputs a public key $pk$ and a secret key $sk$.\n",
    "\n",
    "\n",
    "- An encryption algorithm **Enc** that takes as input the public key $pk$ and a message $m$, and outputs a ciphertext $c$. Since **Enc** is a randomized algorithm, there will be several valid encryptions of a message $m$ under the key $pk$; with $Enc(m, pk)$ we will denote the set of such ciphertexts.\n",
    "\n",
    "\n",
    "- And a decryption algorithm Dec which is run on input $c$, $sk$ and outputs $m$, such that $c \\in Enc(m, pk)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A $(t, n)$ threshold cryptosystem $T\\epsilon$, consists of the following protocols for $n$ players $P_1 , \\cdots , P_n$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- A key generation protocol **TEnc-Key-Gen** that takes as input a security parameter $\\lambda$, and the parameter $t, n$, and it outputs a public key $pk$ and a vector of secret keys $(sk_1, \\cdots, sk_n)$ where $sk_i$ is private to player $P_i$ . This protocol could be obtained by having a trusted party run Enc-Key-Gen and sharing sk among the players.\n",
    "\n",
    "\n",
    "- A threshold decryption protocol **TDec**, which is run on public input a ciphertext $c$ and private input the share $sk_i$ . The output is $m$, such that $c\\in Enc(m, pk)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Threshold variations of Paillier’s scheme have been presented in the literature:\n",
    "\n",
    "* O. Baudron, P.-A. Fouque, D. Pointcheval, G. Poupard and J. Stern. Practical Multi-Candidate Election System. PODC’01\n",
    "\n",
    "* I. Damg˚ard and M. Jurik. A Generalisation, a Simpliﬁcation and Some Appli- cations of Paillier’s Probabilistic Public-Key System. PKC’01, LNCS Vol.1992, pp.119–136\n",
    "\n",
    "* I. Damg˚ard, M. Koprowski: Practical Threshold RSA Signatures without a Trusted Dealer. EUROCRYPT 2001: LNCS Vol.2045, pp. 152-165\n",
    "\n",
    "* C. Hazay, G.L. Mikkelsen, T. Rabin, T. Toft. and A.A. Nicolosi: Eﬃcient RSA key generation and threshold Paillier in the two-party setting."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Independent Trapdoor Commitments"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A trapdoor commitment scheme allows a sender to commit to a message with information-theoretic privacy."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "A (non-interactive) **trapdoor commitment scheme** consists of four algorithms $KG, Com, Ver, Equiv$ with the following properties:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- $KG$ is the key generation algorithm, on input the security parameter it outputs a pair $pk, tk$ where $pk$ is the public key associated with the commitment scheme, and $tk$ is called the **trapdoor**."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- $Com$ is the commitment algorithm. On input pk and a message M it outputs $[C(M), D(M)] = Com(pk, M, R)$ where $r$ are the coin tosses. $C(M)$ is the commitment string, while $D(M)$ is the decommitment string which is kept secret until opening time."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* $Ver$ is the veriﬁcation algorithm. On input $C, D$ and $pk$ it either outputs a message M or $\\bot$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* $Equiv$ is the algorithm that opens a commitment in any possible way given the trapdoor information. It takes as input $pk$, strings $M, R$ with $[C(M), D(M)] = Com(pk, M, R)$, a message $M' \\neq M$ and a string $T$. If $T = tk$ then $Equiv$ outputs $D'$ such that $Ver(pk, C(M), D') = M'$ ."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We note that if the sender refuses to open a commitment we can set $D = \\bot$ and $Ver(pk, C, \\bot) = \\bot$. Trapdoor commitments must satisfy the following properties:\n",
    "\n",
    "* **Correctness:**\n",
    "\n",
    "     If $[C(M), D(M)] = Com(pk, M, R)$ then $Ver(pk, C(M), D(M)) = M$.\n",
    "\n",
    "\n",
    "* **Information Theoretic Security:**\n",
    "\n",
    "     For every message pair $M, M'$ the distributions $C(M$) and $C(M')$ are statistically close.\n",
    "\n",
    "\n",
    "* **Secure Binding:**\n",
    "\n",
    "    We say that an adversary $A$ wins if it outputs $C, D, D'$ such that $Ver(pk, C, D) = M, Ver(pk, C, D') = M'$ and $M \\neq M'$ . We require that for all eﬃcient algorithms $A$, the probability that $A$ wins is negligible in the security parameter.\n",
    "    \n",
    "* **Independence:**\n",
    "\n",
    "    if the honest parties open their commitments in diﬀerent ways using the trapdoor, the adversary cannot change the way he opens his commitments C_j based on the honest parties’ opening."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## II. The Digital Signature Standard"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We deﬁne a generic **G-DSA** signature algorithm as follows. The public parameters include a cyclic group $G$ of prime order $q$ generated by an element $g$, a hash function $H$ deﬁned from arbitrary strings into $Z_q$ , and another hash function $H'$ deﬁned from $G$ to $Z_q$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Secret Key $x$ chosen uniformly at random in $Z_q$.\n",
    "\n",
    "* Public Key $y = g^x$ computed in $G$.\n",
    "\n",
    "* Signing Algorithm on input an arbitrary message $M$, we compute $m = H(M) ∈ Z_q$, Then the signer chooses $k$ uniformly at random in $Z_q$ and computes $R = g^k$ in $G$ and $r = H'(R) ∈ Z_q$ . Then she computes\n",
    "\n",
    "$$\n",
    "s = \\frac{m + xr}{k}\n",
    "$$\n",
    "\n",
    "The signature on $M$ is the pair $(r, s)$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Veriﬁcation Algorithm On input $M, (r, s)$ and $y$, the receiver checks that $r, s ∈ Z_q$ and computes:\n",
    "\n",
    "$$\n",
    "R' = g^{ms^{-1}}y^{ms^{-1}}\n",
    "$$\n",
    "\n",
    "and accepts if $H'(r')=r.$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### 2.1 Threshold DSA\n",
    "\n",
    "in a $(t, n)$-threshold signature scheme the secret key is shared among n servers, in such a way that any $t$ of them has no information about the secret key, while $n$ players can sign a message using a communication protocol that does not require the secret key to be reconstructed at a single server. A scheme is threshold-optimal if exactly $n = t + 1$ honest players can sign."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## III  scheme"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Initialization phase"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this phase, a common reference string containing the public information $pk$ for an independent trapdoor commitment $KG$, $Com$, $Ver$, $Equiv$ is selected and published. This could be accomplished by a trusted third party, who can be assumed to erase any secret information (i.e. the trapdoor of the commitment) after selection.\n",
    "\n",
    "The common parameters $G, g, q$ for the DSA scheme are assumed to be known.\n",
    "\n",
    "\n",
    "\n",
    "---------------"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key generation protocol"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.types.algebra.concrete import EllipticCurveCyclicSubgroupSecp256k1 as ECC\n",
    "from klefki.types.algebra.concrete import EllipticCurveGroupSecp256k1 as Cruve\n",
    "from klefki.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from klefki.types.algebra.concrete import FiniteFieldSecp256k1 as F\n",
    "from klefki.zkp.pedersen import PedersonCommitment\n",
    "from klefki.types.algebra.utils import randfield\n",
    "from klefki.bitcoin.address import gen_address"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here we describe how the players can jointly generate a DSA key pair $(x, y = g_x)$ with $y$ public and $x$ shared among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The idea is to generate a public key $E$ for an additively $(\\mod N)$ homomorphic encryption scheme $E$, together with the secret key $D$ in shared form among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The value $N$ is is chosen to be larger than $q^8$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.crypto.paillier import Paillier\n",
    "from klefki.zkp.pedersen import PedersonCommitment, com as commit\n",
    "from functools import partial\n",
    "from klefki.types.algebra.concrete import FiniteFieldCyclicSecp256k1 as CF\n",
    "from klefki.numbers.primes import generate_prime\n",
    "from functools import reduce\n",
    "from operator import mul, add"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "q = CF(CF.P)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "P = generate_prime(1024)\n",
    "Q = generate_prime(1024)\n",
    "Pai = Paillier(P, Q)\n",
    "E, D = Pai.E, Pai.D"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then a value $x$ is generated, and encrypted with E, with the value $α = E(x)$ made public.\n",
    "\n",
    "Note that this is an implicit $(t, n)$ secret sharing of $x$, since the decryption key of $E$ is shared among the players."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Each player $P_i$ selects a random value $x_i ∈ Z_q$ , computes $y_i$ = $g_{x_i} ∈ G$ and $[C_i , D_i ] = Com(y_i)$;"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "G = ECC.G\n",
    "n = 3\n",
    "xs = [randfield(CF) for _ in range(n)]\n",
    "ys = [G ** x for x in xs]\n",
    "\n",
    "trap = randfield(CF)\n",
    "H = G ** trap\n",
    "com = partial(PedersonCommitment, H=H, G=G)\n",
    "\n",
    "coms = [com(x=y.value[0], r=y.value[1]) for y in ys]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = reduce(add, xs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Each player $P_i$ broadcast $C_i$\n",
    "    * $D_i$ which allows everybody to compute $y_i = Ver(C_i , D_i )$\n",
    "    * $\\alpha_i=E(x_i);$\n",
    "    * a ZK argument $\\Pi_i$ that states\n",
    "        * $\\exists \\mu=y_i$\n",
    "        * $D(a_i)=\\mu$\n",
    "        \n",
    "      If any of the ZK arguments fails, the protocol terminates."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "from operator import mul\n",
    "from klefki.types.algebra.meta import field"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "from operator import add\n",
    "from functools import reduce\n",
    "\n",
    "alpha = reduce(mul, [E(x.value) for x in xs])\n",
    "y = reduce(add, ys)\n",
    "FN = alpha.functor"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(alpha)) == reduce(add, xs) == x\n",
    "assert G ** CF(D(alpha)) == y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- The players compute $\\alpha=\\oplus_{i=1}^{t+1}a_i$ and $y=\\sum_{i=1}^{t+1}y_i$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Signature Generation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The signature generation protocol is run on input $m$ (the hash of the message $M$ being signed)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from klefki.utils import to_sha256int\n",
    "\n",
    "m = CF(to_sha256int(\"Hello Threshold ECDSA\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Round 1\n",
    "\n",
    "Each player $P_i$\n",
    "    \n",
    "1. choose $\\rho_i \\leftarrow Z_q$\n",
    "\n",
    "2. compute $u_i=E(\\rho_i)$ and $v_i=p_i \\times_E\\alpha = E(\\rho_ix)$\n",
    "\n",
    "3. compute $[C_{1,i}, D_{i,i}]=Com([u_i, v_i])$ and broadcast $C_{1,i}$\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "ps = [randfield(CF) for _ in range(n)]\n",
    "us = [E(p) for p in ps]\n",
    "vs = [alpha ** p for p in ps]\n",
    "\n",
    "coms1 = [com(x=t[0], r=t[1]) for t in zip(us, vs)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "##### Round 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player $P_i$ broadcasts:\n",
    "   \n",
    "* $D_{1,i}$. This allow everybody to compute $[u_i, v_i]=Ver(C_{1,i}, D_{1,i})$\n",
    "\n",
    "* a zero-knowledge argument $\\Pi_{1,i}$ which states\n",
    "\n",
    "    - $\\exists \\eta \\in [-q^3,q^3]$ such that\n",
    "    \n",
    "        $D(u_i)=\\eta$\n",
    "        \n",
    "        $D(v_i)=\\eta D(E(x)$\n",
    "        \n",
    "        \n",
    "Players compute $u=\\oplus_{i=1}^{t+1}u_i=E(\\rho)$ and $v=\\oplus_{i=1}^{t+1}v_i=E(\\rho x)$, where $\\rho=\\sum_{i=1}^{1+1}\\rho_i$\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "u = reduce(mul, us)\n",
    "v = reduce(mul, vs)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(u)) == reduce(add, (ps))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "assert CF(D(alpha ** ps[1])) == x * ps[1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(alpha ** ps[0] * alpha ** ps[1] * alpha ** ps[2])) == x * (ps[0] + ps[1] + ps[2]) == CF(D(v))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(v)) == CF(D(E(reduce(add, ps) * x)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player $P_i$\n",
    "\n",
    "- choose $k_i \\in Z_q$ and $c_i \\in R[-q^6, q^6]$\n",
    "- computes $r_i=g^{k_i}$ and $w_i=(k_i\\times_E u) +_E E(c_iq)=E(k_i\\rho+c_iq))$\n",
    "- computes $[C_{2,i},D_{2_i}=Com(r_i,w_i)$ and broadcast $C_{2i}$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "ks = [randfield(CF) for _ in range(n)]\n",
    "rs = [G**k for k in ks]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "cs = [randfield(CF) for _ in range(n)]\n",
    "ws = [(u ** k) * E(c*q) for c, k in zip(cs, ks)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "coms2 = [com(x=c, r=w) for c, w in zip(cs, ws)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "dcoms2 = [c.D for c in coms]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(u ** ks[0])) == reduce(add, (ps)) * ks[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(u ** ks[0] * E(cs[0] * q))) == CF(D(u ** ks[0]) + D(E(cs[0] * q))) \\\n",
    "                                 == reduce(add, (ps)) * ks[0] + cs[0] * q"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 4"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Each player P_i broadcasts\n",
    "\n",
    "1. $D_{2,i}$, which allows everybody to compute $[r_i , w_i ]$ = $Ver(C_{2,i} , D_{2,i} )$\n",
    "    \n",
    "2. a zero-knowledge argument $Π_{(2,i)}$\n",
    "    \n",
    "Players compute $w=\\oplus_{i=1}^{t+1}w_i=E(k\\rho + cq)$ where $k=\\sum_{i=1}^{t+1}k_i$ and $c=\\sum_{i=1}^{t+1}c_i$. Players also compute $R=\\Pi_i^{t+1}r_i=g^k$ and $r=H'(R)\\in Z_q$\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 27,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "all([c.C == commit(H=H, G=G, *c.D) for c in coms2])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "w = reduce(mul, ws)\n",
    "R = reduce(mul, rs)\n",
    "r = CF(R.x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "R == G ** reduce(add, ks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "CF(D(w)) == reduce(add, (ps)) * reduce(add, ks) + reduce(add, cs) * q"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 5\n",
    "\n",
    "players jointly decrypt $w$ using **TDec** to learn the value $\\tau ∈ [−q^7 , q^7]$ such that $\\tau = kρ \\mod q$ and $ψ = η ^{−1} \\mod q$\n",
    "\n",
    "Each player computes:\n",
    "\n",
    "\n",
    "\\begin{align}\n",
    "\\sigma &= \\psi \\times_E [m\\times_E u]+_E(r\\times_E v)]\\\\\n",
    "&= \\psi \\times_E [E(m\\rho) +_E E(r \\rho x)]\\\\\n",
    "&= (k^{-1\\rho^{-1}}\\times_E [E(\\rho (m+xr)) \\\\\n",
    "&=E(k^{-1}(m+xr))\\\\\n",
    "&=E(s)\n",
    "\\end{align}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "psi = CF(D(w))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "pai = ~psi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "sigma = ((u**m) * (v**r)) ** pai"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Proof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "x = reduce(add, xs)\n",
    "p = reduce(add, ps)\n",
    "k = reduce(add, ks)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(u**m)) == m * p\n",
    "assert CF(D(v**r)) == r * p * x\n",
    "assert CF(D(u**m)) + CF(D(v**r)) == p * (m + x * r)\n",
    "assert CF(D((u**m) * (v**r))) == p * (m + x * r)\n",
    "assert CF(D(((u**m) * (v**r)) ** pai)) == (m + x * r)/k"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "assert CF(D(sigma)) == (m + x * r)/k\n",
    "assert (G ** k).x == r"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Round 6\n",
    "\n",
    "The players invoke distributed decryption protocol TDec over the ciphertext $σ$. Let $s = D(σ) mod q$. The players output $(r, s)$ as the signature for $m$.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "r, s = r, CF(D(sigma))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.crypto.ecdsa.secp256k1 import verify"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "verify(pub=y, sig=(r, s), msg=\"Hello Threshold ECDSA\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Ref:\n",
    "\n",
    "* Antonio Salazar Cardozo, Threshold ECDSA — Safer, more private multi-signatures, https://blog.keep.network/threshold-ecdsa-safer-more-private-multi-signatures-51153f3e9ed2\n",
    "\n",
    "* Gennaro, Rosario, Steven Goldfeder, and Arvind Narayanan. “Threshold-Optimal DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security.” In Applied Cryptography and Network Security, edited by Mark Manulis, Ahmad-Reza Sadeghi, and Steve Schneider, 9696:156–74. Cham: Springer International Publishing, 2016. https://doi.org/10.1007/978-3-319-39555-5_9.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
