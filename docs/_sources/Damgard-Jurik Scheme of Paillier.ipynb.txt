{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Damgard-Jurik Scheme of Paillier\n",
    "================"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Generalisation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The publickey cryptosystem uses computations modulo $n^{s+1}$ where $n$ is an $RSA$ modulus and $s$ is a natural number. It contains **Paillier's scheme** as a special case by setting $s=1$"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We start from the observation that if $n=pq,p,q$ odd primes, then $Z^*_{n^{s+1}}$ as a multiplicative group is a direct product $G\\times H$, where $G$ ic cyclic of order $n^s$ and $H$ is isomorphic to $Z^*_{n}$, which follows directly from elementary number theory.\n",
    "\n",
    "Thus, the factor group $\\bar{G}=Z*_{n^{s+1}}/H$ is also cyclic of order $n^s$. For an arbitary element $a \\in Z_n^{s+1}$, we let $\\bar{a}  H$ we denote the element represented by $a$ in the factor group $\\bar{G}$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "* Lemma 1: For any $s< p, q$, the element $n+1$ has order $n^s$ in $Z_n^{s+1}$."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It is easy to compute $i$ from $(1+n)^i \\mod n^{s+1}$. If we define the function $L()$ by $L(b)=(b-1)/n$ then clealy we have:\n",
    "\n",
    "$$\n",
    "L((1+n)^i \\mod n^{n+1}) =(1 + \\binom i 2 n + \\cdots + \\binom i s n ^{s-1} ) \\mod n ^s\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.types.algebra.meta import field\n",
    "from klefki.types.algebra.utils import randfield"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.numbers.primes import generate_prime\n",
    "\n",
    "k = 32\n",
    "p, q = generate_prime(k), generate_prime(k)\n",
    "\n",
    "s = 1 # for the pailer case\n",
    "\n",
    "n = p * q\n",
    "j = generate_prime(k)\n",
    "\n",
    "F = field(n**s) # n ** s == n if s = 1\n",
    "MF = field(n ** (s+1)) # n ** (s +1 ) == n2 in pailer case\n",
    "H = field(n)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Key Generation"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On input the security parameter $k$, choose an $RSA$ modulus $n=pq$ of length $k$ bits. Also choose an element $g\\in Z_n^{s+1}$ such that $g=(1+n)^j$ mod $n^{s+1}$ for a known $j$ relatively prime to $n$ and $x \\in H$.\n",
    "\n",
    "This can be done, $e.g$, by choosing $j, x$ as random first and computing $g$;\n",
    "\n",
    "Let $\\lambda$ be the $lcm$ of $p-1$ and $q-1$. By the Chinese Remainder Theorem, choose $d$ such that $d$ mod $n\\in Z_n$ and $d=0$ mod $\\lambda$. \n",
    "\n",
    "$$\n",
    "d \\equiv \\left\\{\n",
    "\\begin{aligned}\n",
    "0 &\\mod \\phi(N) \\\\\n",
    "Z_n &\\mod N\n",
    "\\end{aligned}\n",
    "\\right\\}\n",
    "$$\n",
    "\n",
    "\n",
    "Any such choice of $d$ will work in the following.\n",
    "\n",
    "Now the pubkey is $n, g$ while the secret key is $d$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "from klefki.numbers.primes import generate_prime\n",
    "from klefki.numbers import lcm\n",
    "from random import randint\n",
    "from math import gcd"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "j = generate_prime(32)\n",
    "assert gcd(j, n) == 1\n",
    "x = MF(randfield(H))\n",
    "assert x.value < H.P\n",
    "g = MF(1 + n) ** j * x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "lam = lcm(p-1, q-1)\n",
    "LF = field(lam)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "#d = randint(1, int(n / lam)) * lam\n",
    "d = lam\n",
    "assert d < n\n",
    "assert d % lam == 0\n",
    "\n",
    "pubkey = (n, g)\n",
    "privkey = d"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Encryption"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The paintext set is $Z_{n^s}$. Given a paintext $i$, choose a random $r \\leftarrow Z^*_{n^{s+1}}$, and lte the cipertext be $E(i, r) = g^ir^{n^s} \\mod n^{s+1}$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "r = randfield(MF)\n",
    "i = randfield(F).value\n",
    "e = lambda i, r: g ** i * r ** (n**s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "c = e(i, r)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Decryption"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given a ciphertext $c$, first compute $c^d \\mod n^{s+1}$, Clearly, if $c=E(v, r)$, we get\n",
    "\n",
    "\\begin{align}\n",
    "c^d &= (g^i r^{n^s})^d\\\\\n",
    "&=((1+n)^{ij} x^i r^{n^s})^d\\\\\n",
    "&=(1+n)^{jid \\mod n^s}(x^ir^{n^s})^{d \\mod \\lambda}\\\\\n",
    "&=(1+n)^{jid \\mod n^s}\n",
    "\\end{align}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "c ** d ==  (g ** i * r ** (n**s))**d \\\n",
    "       == ((MF(1 + n) ** j * x) ** i * r ** (n**s))**d \\\n",
    "       == (MF(1 + n) ** (j * i) * x ** i * r ** (n**s))**d \\\n",
    "       == MF(1 + n) ** (j * i * d) * (x ** i * r ** (n**s)) ** d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "F(c ** d) == F(MF(1 + n) ** (j * i * d))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Threshold DJS of Paillier"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "from damgard_jurik import keygen\n",
    "\n",
    "public_key, private_key_ring = keygen(\n",
    "    n_bits=512,\n",
    "    s=3,\n",
    "    threshold=100,\n",
    "    n_shares=300\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[mpz(1),\n",
       " mpz(17),\n",
       " mpz(70),\n",
       " mpz(265),\n",
       " mpz(169),\n",
       " mpz(200),\n",
       " mpz(231),\n",
       " mpz(223),\n",
       " mpz(55),\n",
       " mpz(35),\n",
       " mpz(43),\n",
       " mpz(30),\n",
       " mpz(91),\n",
       " mpz(101),\n",
       " mpz(264),\n",
       " mpz(29),\n",
       " mpz(135),\n",
       " mpz(156),\n",
       " mpz(14),\n",
       " mpz(216),\n",
       " mpz(204),\n",
       " mpz(25),\n",
       " mpz(191),\n",
       " mpz(58),\n",
       " mpz(145),\n",
       " mpz(296),\n",
       " mpz(233),\n",
       " mpz(134),\n",
       " mpz(280),\n",
       " mpz(87),\n",
       " mpz(143),\n",
       " mpz(174),\n",
       " mpz(181),\n",
       " mpz(220),\n",
       " mpz(165),\n",
       " mpz(164),\n",
       " mpz(289),\n",
       " mpz(23),\n",
       " mpz(255),\n",
       " mpz(184),\n",
       " mpz(277),\n",
       " mpz(4),\n",
       " mpz(235),\n",
       " mpz(197),\n",
       " mpz(36),\n",
       " mpz(126),\n",
       " mpz(142),\n",
       " mpz(113),\n",
       " mpz(155),\n",
       " mpz(13),\n",
       " mpz(263),\n",
       " mpz(198),\n",
       " mpz(77),\n",
       " mpz(93),\n",
       " mpz(83),\n",
       " mpz(178),\n",
       " mpz(132),\n",
       " mpz(84),\n",
       " mpz(182),\n",
       " mpz(60),\n",
       " mpz(217),\n",
       " mpz(40),\n",
       " mpz(51),\n",
       " mpz(71),\n",
       " mpz(76),\n",
       " mpz(139),\n",
       " mpz(248),\n",
       " mpz(166),\n",
       " mpz(271),\n",
       " mpz(286),\n",
       " mpz(15),\n",
       " mpz(256),\n",
       " mpz(241),\n",
       " mpz(175),\n",
       " mpz(45),\n",
       " mpz(105),\n",
       " mpz(67),\n",
       " mpz(261),\n",
       " mpz(279),\n",
       " mpz(21),\n",
       " mpz(86),\n",
       " mpz(228),\n",
       " mpz(249),\n",
       " mpz(273),\n",
       " mpz(283),\n",
       " mpz(292),\n",
       " mpz(167),\n",
       " mpz(73),\n",
       " mpz(53),\n",
       " mpz(257),\n",
       " mpz(88),\n",
       " mpz(109),\n",
       " mpz(173),\n",
       " mpz(258),\n",
       " mpz(140),\n",
       " mpz(281),\n",
       " mpz(224),\n",
       " mpz(27),\n",
       " mpz(56),\n",
       " mpz(254)]"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "private_key_ring.i_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "mpz(42)"
      ]
     },
     "execution_count": 19,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "m = 42\n",
    "c = public_key.encrypt(m)\n",
    "private_key_ring.decrypt(c)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Ref:\n",
    "    \n",
    "* I. Damg˚ard and M. Jurik. A generalisation, a simpliﬁcation and some applications of paillier’s proba- bilistic public-key system. In Public Key Cryptography, pages 119–136, 2001.\n",
    "    \n",
    "    \n",
    "* Damgard-Jurik implementation https://github.com/cryptovoting/damgard-jurik"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
